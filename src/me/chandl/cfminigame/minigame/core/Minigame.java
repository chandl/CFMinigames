package me.chandl.cfminigame.minigame.core;

import me.chandl.cfminigame.handler.GameHandler;
import me.chandl.cfminigame.minigame.player.MinigamePlayer;
import me.chandl.cfminigame.minigame.player.PlayerState;
import me.chandl.cfminigame.util.Message;
import org.bukkit.ChatColor;
import org.bukkit.event.entity.PlayerDeathEvent;
import org.bukkit.event.player.PlayerRespawnEvent;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * Minigame - Main representation of all Minigames.
 *
 * @author Chandler me@cseverson.com
 * @version 1.0
 * @since Aug 19, 2017
 */
public abstract class Minigame {
    private Date startTime;
    private MinigameType type;
    private int maximumPlayers, minimumPlayers;
    private MinigameMap map;
    private int difficultyLevel;
    private List<MinigamePlayer> scoreboard;

    public Minigame(){}

    //Methods that children should implement.
    public abstract void start ();
    public abstract void stop ();
    protected abstract boolean isGameFinished();


    /**
     * Default onPlayerJoin Method for Minigames.
     * Clears Player's Inventory, Saving previous inventory for after game.
     * Teleports Player to the Minigame Spawn Point
     * Gives Player the Minigame Starting items.
     *
     * @param player The player that is joining the minigame.
     */
    public void onPlayerJoin(MinigamePlayer player){
        switch(GameHandler.getHandler().getCurrentState()){
            case IN_GAME:
                player.getHandler().minigameJoinInProgressAction();
                //notify all players of someone new in the MG.
                Message.allPlayers(String.format("%s started spectating the minigame! [%d/%d Players]", player.getPlayerObject().getDisplayName(), GameHandler.getHandler().getPlayerList().size(), getMaximumPlayers()));
                break;

            case IN_QUEUE:
                player.getHandler().minigameJoinInQueueAction();
                //notify all players of someone new in the MG.
                Message.allPlayers(String.format("%s just joined the minigame! [%d/%d Players]", player.getPlayerObject().getDisplayName(), GameHandler.getHandler().getPlayerList().size(), getMaximumPlayers()));
                break;

            case NO_GAME:
            default:
                System.out.println("This ERROR should never show. If it does, ur fucked. ");
                break;
        }

    }

    /**
     * Called when a player leaves the current minigame.
     *
     * @param player The player that left the minigame.
     */
    public void onPlayerLeave(MinigamePlayer player){
        player.getHandler().minigameLeaveAction();

        //notify all players of someone leaving the MG.
        if(GameHandler.getHandler().getPlayerList().size() != 0)
            Message.allPlayers(String.format("%s just left the minigame! [%d/%d Players]", player.getPlayerObject().getDisplayName(), GameHandler.getHandler().getPlayerList().size(), getMaximumPlayers()));
    }

    /**
     * Called when a Player finishes the Minigame.
     *
     * @param player The player that finished the minigame.
     */
    public void onPlayerFinish(MinigamePlayer player){

        //Scoreboard Stuff
        if(scoreboard == null) {
            scoreboard = new ArrayList<>();
        }
        Date finished = new Date();
        long timeTaken = (finished.getTime() - startTime.getTime()) / 1000;

        //Call PlayerHandler.minigameFinishAction()
        player.getHandler().minigameFinishAction(timeTaken);

        //Add player to scoreboard
        scoreboard.add(player);

        //Notify all players in game & the console of who finished the Minigame.
        Message.playersInGame(player.getPlayerObject().getName() + " Finished the Minigame in position " + scoreboard.size() + "! Time: " + timeTaken + " seconds." );
        System.out.println(player.getPlayerObject().getName() + " Finished the Minigame in position " + scoreboard.size() + "! Time: " + timeTaken + " seconds.");


        //Check if game is finished,
        if(isGameFinished()){
            MinigamePlayer winner = scoreboard.get(0);
            Message.allPlayers("INFO", "The Current Minigame Has Finished! 1st Place was " + winner.getPlayerObject().getName() + " at " + winner.getGameTime() + " seconds.");
            System.out.println("The Current Minigame Has Finished! 1st Place was " + winner.getPlayerObject().getName() + " at " + winner.getGameTime() + " seconds.");

            GameHandler.getHandler().stopMinigame();
        }
    }

    /**
     * Called when a Player Respawns in the Minigame.
     *
     * @param event The Respawn Event generated by Minecraft when a player respawns.
     * @param player The player that is respawning.
     */
    public void onPlayerRespawn(PlayerRespawnEvent event, MinigamePlayer player){
        //Call minigameRespawnAction in Player's Handler
        player.getHandler().minigameRespawnAction(event);
    }


    /**
     * Called when a Player is Damaged in the Minigame.
     * Implementation is dependent on the Mingiame Type.
     *
     * @param player The player that was damaged.
     */
    public void onPlayerDamage(MinigamePlayer player){}

    /**
     * Called when a Player Dies in the Minigame.
     *
     * @param event the Death Event generated by Minecraft when a player dies.
     * @param player The player that died.
     */
    public void onPlayerDie(PlayerDeathEvent event, MinigamePlayer player){

        //Call PlayerHandler.minigameDeathAction()
        player.getHandler().minigameDeathAction();

        event.getDrops().clear();

        //Check if minigame is over now.
        if(player.getState() == PlayerState.SPECTATING){ //player just died for the last time
            Message.player(player, "You have Died and have used all of your lives. Spectating now.");

            if(isGameFinished()){
                if(scoreboard == null || scoreboard.size() == 0){
                    Message.allPlayers("INFO", "The Current Minigame has Finished! Nobody was able to complete it!!");
                }else{
                    Message.allPlayers("INFO", "The Current Minigame Has Finished! 1st Place was " + scoreboard.get(0).getPlayerObject().getName() + " at " + scoreboard.get(0).getGameTime() + " seconds.");
                }

                GameHandler.getHandler().stopMinigame();
            }
        }else{
            Message.player(player, ChatColor.DARK_RED + "You Have Died!"+ ChatColor.WHITE +" Remaining Lives: " + player.getCurrentLifeCount());
        }

    }

    //===================Getters & Setters, toString====================
    @Override
    public String toString(){
        String out = String.format("[%s] %s Minigame. Map: %s. Difficulty: %d. " +
                        "Max Players: %d, Min Players: %d.", startTime.toString(),
                type,
                map.getName(),
                difficultyLevel,
                maximumPlayers,
                minimumPlayers);
        return out;
    }

    public void setStartTime(Date startTime) {
        this.startTime = startTime;
    }

    public MinigameType getType() {
        return type;
    }

    public void setType(MinigameType type) {
        this.type = type;
    }

    public int getMaximumPlayers() {
        return maximumPlayers;
    }

    public void setMaximumPlayers(int maximumPlayers) {
        this.maximumPlayers = maximumPlayers;
    }


    public void setMinimumPlayers(int minimumPlayers) {
        this.minimumPlayers = minimumPlayers;
    }

    public MinigameMap getMap() {
        return map;
    }

    public void setMap(MinigameMap map) {
        this.map = map;
    }

    public int getDifficultyLevel() {
        return difficultyLevel;
    }

    public void setDifficultyLevel(int difficultyLevel) {
        this.difficultyLevel = difficultyLevel;
    }
}
